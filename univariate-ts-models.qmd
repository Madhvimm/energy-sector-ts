---
title: "Univariate TS Models (ARIMA/SARIMA)"
output: distill::distill_article
---

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: false
library(ggplot2)
library(readr)
library(tidyverse)
library(lubridate)
library(forecast)
library(tseries)
library(plotly)
library(gridExtra)
library(zoo)

library(ggplot2)
library(zoo)
library(plotly)

```

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Read data'
#| warning: false
#| output: false

composite_crude_oil_prices <- read.csv("data/composite_crude_oil_prices.csv")
citygate_gas_prices <- read.csv("data/citygate_gas_prices.csv")
total_electricity_prices <- read.csv("data/total_electricity_prices.csv")
gdp_data <- read.csv("data/gdp_data.csv")
cpi_data <- read.csv("data/cpi_data.csv")

```

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'convert to ts'
#| warning: false
#| output: false


# For Crude Oil
composite_crude_oil_prices$Date <- as.Date(composite_crude_oil_prices$Date)
start_year <- as.numeric(format(min(composite_crude_oil_prices$Date), "%Y"))
start_month <- as.numeric(format(min(composite_crude_oil_prices$Date), "%m"))
composite_crude_oil_ts <- ts(composite_crude_oil_prices$Value, start=c(start_year, start_month), frequency=12)


# For Natural Gas
citygate_gas_prices$Date <- as.Date(citygate_gas_prices$Date)
start_year_gas <- as.numeric(format(min(citygate_gas_prices$Date), "%Y"))
start_month_gas <- as.numeric(format(min(citygate_gas_prices$Date), "%m"))
citygate_gas_ts <- ts(citygate_gas_prices$Value, start=c(start_year_gas, start_month_gas), frequency=12)

# For Electricity
total_electricity_prices$Date <- as.Date(total_electricity_prices$Date, format = "%Y-%m-%d")
start_year_elec <- as.numeric(format(min(total_electricity_prices$Date), "%Y"))
start_month_elec <- as.numeric(format(min(total_electricity_prices$Date), "%m"))
total_electricity_ts <- ts(total_electricity_prices$Value, start = c(start_year_elec, start_month_elec), frequency = 12)

# For GDP (it's quarterly)
gdp_data$DATE <- as.Date(gdp_data$DATE, format = "%Y-%m-%d")
start_year_gdp <- as.numeric(format(min(gdp_data$DATE), "%Y"))
start_quarter_gdp <- quarter(min(gdp_data$DATE))
gdp_ts <- ts(gdp_data$GDP, start = c(start_year_gdp, start_quarter_gdp), frequency = 4)


# For CPI (it's monthly)
cpi_data$DATE <- as.Date(cpi_data$DATE, format = "%Y-%m-%d")
start_year_cpi <- as.numeric(format(min(cpi_data$DATE), "%Y"))
start_month_cpi <- as.numeric(format(min(cpi_data$DATE), "%m"))
cpi_ts <- ts(cpi_data$CPIAUCSL, start = c(start_year_cpi, start_month_cpi), frequency = 12)
```

# ACF & PACF Plots

Autocorrelation Function (ACF) and Partial Autocorrelation Function (PACF) plots are crucial tools in time series analysis, helping to identify the type of model that best describes a series. The ACF plot shows the correlation of the series with its own lags, providing insights into the overall correlation structure and potential seasonality. On the other hand, the PACF plot reveals the direct effect of past values on the current value, helping to pinpoint the order of autoregressive models.

By examining the ACF and PACF plots, we can discern patterns that suggest the presence of autoregressive (AR) or moving average (MA) components in our time series models. Significant spikes in the ACF plot indicate potential AR terms, while significant spikes in the PACF plot suggest MA terms. These plots also assist in determining the stationarity of the series, a crucial aspect in time series modeling, where non-stationary data often require differencing to achieve stationarity.

In this section, we'll explore the ACF and PACF plots for our datasets delving into their autocorrelation structures and deriving insights that will inform our model selection and forecasting approach.

::: panel-tabset
## Crude Oil

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# ACF and PACF for Crude Oil
crude_oil_acf <- ggAcf(composite_crude_oil_ts) + 
  ggtitle("ACF Plot for Refiner Acquisition Cost of Crude Oil") + 
  theme_bw() +
  geom_segment(lineend = "butt", color = "turquoise4") +
  geom_hline(yintercept = 0, color = "turquoise4") 

crude_oil_pacf <- ggPacf(composite_crude_oil_ts) + 
  ggtitle("PACF Plot for Refiner Acquisition Cost of Crude Oil") + 
  theme_bw() +
  geom_segment(lineend = "butt", color = "turquoise4") +
  geom_hline(yintercept = 0, color = "turquoise4") 

grid.arrange(crude_oil_acf, crude_oil_pacf, nrow = 2)


```

The **ACF plot** for crude oil prices demonstrates prolonged significant autocorrelation, suggesting a non-stationary series. The gradual decline in correlation as lags increase indicates a potential long-term dependency or trend in the data.

The **PACF plot** shows significant spike at lag 1 and 2, followed by non-significant values

The ACF and PACF plots suggest considering an ARIMA model with 'p' to be 1 and 2. The slow decay in the ACF implies that differencing (d \> 0) may be necessary to achieve stationarity.

## Natural Gas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# ACF and PACF for Natural Gas
natural_gas_acf <- ggAcf(citygate_gas_ts) + 
  ggtitle("ACF Plot for Natural Gas Price") + 
  theme_bw() +
  geom_segment(lineend = "butt", color = "turquoise4") +
  geom_hline(yintercept = 0, color = "turquoise4") 

natural_gas_pacf <- ggPacf(citygate_gas_ts) + 
  ggtitle("PACF Plot for Natural Gas Price") + 
  theme_bw() +
  geom_segment(lineend = "butt", color = "turquoise4") +
  geom_hline(yintercept = 0, color = "turquoise4") 

grid.arrange(natural_gas_acf, natural_gas_pacf, nrow = 2)


```

The **ACF plot** for natural gas prices shows a very slow decay, suggesting non-stationarity and a need for differencing.

The **PACF plot** shows a significant spike at lag 1, followed by a drop-off.

The ACF and PACF plots suggest considering an ARIMA model with 'p' to be 1 and 2. The slow decay in the ACF implies that differencing (d \> 0) may be necessary to achieve stationarity.

## Electricity

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# ACF and PACF for Electricity
electricity_acf <- ggAcf(total_electricity_ts) + 
  ggtitle("ACF Plot for Average Price of Electricity to Ultimate Customers") + 
  theme_bw() +
  geom_segment(lineend = "butt", color = "turquoise4") +
  geom_hline(yintercept = 0, color = "turquoise4") 

electricity_pacf <- ggPacf(total_electricity_ts) + 
  ggtitle("PACF Plot for Average Price of Electricity to Ultimate Customers") + 
  theme_bw() +
  geom_segment(lineend = "butt", color = "turquoise4") +
  geom_hline(yintercept = 0, color = "turquoise4") 

grid.arrange(electricity_acf, electricity_pacf, nrow = 2)


```

The **ACF plot** for electricity shows a strong positive autocorrelation across all the lags indicating a potential MA term and a need for differencing due to non-stationarity.

The **PACF plot** shows a significant correlations at lag 1. The choice of 'p' could be 1 or 2 based on the first significant spikes.

The consistent autocorrelation in the ACF plot suggests a potential need for a higher-order MA term or differencing, leading to an ARIMA(p,d,q) model consideration.

## GDP

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# ACF and PACF for GDP
gdp_acf <- ggAcf(gdp_ts) + 
  ggtitle("ACF Plot for GDP") + 
  theme_bw() +
  geom_segment(lineend = "butt", color = "turquoise4") +
  geom_hline(yintercept = 0, color = "turquoise4") 

gdp_pacf <- ggPacf(gdp_ts) + 
  ggtitle("PACF Plot for GDP") + 
  theme_bw() +
  geom_segment(lineend = "butt", color = "turquoise4") +
  geom_hline(yintercept = 0, color = "turquoise4") 

grid.arrange(gdp_acf, gdp_pacf, nrow = 2)


```

The **ACF plot** for GDP shows a persistent strong autocorrelation across all lags indicates non-stationarity, suggesting that differencing may be necessary.

The **PACF plot** have a sharp cutoff after lag 1 indicating an AR(1) process, suggesting that previous values have a significant impact on current GDP.

Given the strong autocorrelation and the PACF cutoff, an ARIMA(1,1,0) model may be a good starting point for modeling GDP, but differencing (d \> 0) may be necessary.

## CPI

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# ACF and PACF for CPI
cpi_acf <- ggAcf(cpi_ts) + 
  ggtitle("ACF Plot for CPI") + 
  theme_bw() +
  geom_segment(lineend = "butt", color = "turquoise4") +
  geom_hline(yintercept = 0, color = "turquoise4") 

cpi_pacf <- ggPacf(cpi_ts) + 
  ggtitle("PACF Plot for CPI") + 
  theme_bw() +
  geom_segment(lineend = "butt", color = "turquoise4") +
  geom_hline(yintercept = 0, color = "turquoise4") 

grid.arrange(cpi_acf, cpi_pacf, nrow = 2)



```

The **ACF plot** for CPI shows a sustained high autocorrelation across lags suggests a non-stationary time series, indicative of CPI's long memory.

The **PACF plot** have a sharp spike and a cutoff after lag 1 indicating an AR(1) process, suggesting that previous values have a significant impact on current GDP.

The sustained autocorrelation in the ACF plot implies that differencing might be needed. An initial ARIMA(1,1,0) model could be considered.

## 
:::

# Detrend VS Difference

Detrending and differencing are two methods used to make time series data stationary, it involves removing the underlying trend from the data, while differencing focuses on the changes between consecutive observations.

Detrending typically subtracts the estimated trend component from the original series, while differencing transforms the series into the sequence of differences between adjacent values. While detrending addresses the trend, differencing can help eliminate both trend and seasonality, making the series stationary.

::: panel-tabset
## Crude Oil

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Convert residuals to a ts object
fit_crude_oil <- lm(Value ~ Date, data = composite_crude_oil_prices, na.action = NULL)

resid_crude_oil_ts <- ts(resid(fit_crude_oil), start=c(start_year, start_month), frequency=12)

# Now plot the residuals
plot1_crude_oil <- autoplot(resid_crude_oil_ts, series="Detrended Crude Oil", colour = "#00BFC4") + 
  theme_bw() +
  xlab("Time") +
  ylab("Residuals") +
  ggtitle("Detrended Crude Oil")

# Differencing plot remains the same
plot2_crude_oil <- autoplot(diff(composite_crude_oil_ts), series = "First Difference Crude Oil", colour = "#F8766D") + 
  theme_bw() +
  xlab("Time") +
  ylab("Differences") +
  ggtitle("First Difference Crude Oil")

# Arrange plots
grid.arrange(plot1_crude_oil, plot2_crude_oil, nrow = 2)



```

**Detrended:**

The residuals after detrending indicate that linear detrending might not fully account for all underlying components, as patterns still emerge.

**First Difference:**

The differenced series shows fluctuations around zero, indicative of improved stationarity. While the mean appears stabilized, examining autocorrelation in the differenced data is crucial to confirm stationarity fully.

## Natural Gas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Detrending using the original data frame
fit_natural_gas <- lm(Value ~ Date, data = citygate_gas_prices, na.action = NULL)

# Convert residuals to a ts object for plotting
resid_natural_gas_ts <- ts(resid(fit_natural_gas), start=c(start_year_gas, start_month_gas), frequency=12)

# Now plot the residuals
plot1_natural_gas <- autoplot(resid_natural_gas_ts, series="Detrended Natural Gas", colour = "#00BFC4") + 
  theme_bw() +
  xlab("Time") +
  ylab("Residuals") +
  ggtitle("Detrended Natural Gas")

# Differencing plot remains the same
plot2_natural_gas <- autoplot(diff(citygate_gas_ts), series = "First Difference Natural Gas", colour = "#F8766D") + 
  theme_bw() +
  xlab("Time") +
  ylab("Differences") +
  ggtitle("First Difference Natural Gas")

# Arrange plots
grid.arrange(plot1_natural_gas, plot2_natural_gas, nrow = 2)


```

**Detrended:**

The detrended series shows periods of volatility, indicating that removing the linear trend doesn't capture all the data's dynamics, remaining fluctuations may reflect other underlying components like seasonality

**First Difference:**

Consistent mean but varying volatility and a spike around 2020, which could be due to the pandemic

## Electricity

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Detrending using the original data frame
fit_electricity <- lm(Value ~ Date, data = total_electricity_prices, na.action = NULL)

# Convert residuals to a ts object for plotting
resid_electricity_ts <- ts(resid(fit_electricity), start=c(start_year_elec, start_month_elec), frequency=12)

# Plot the residuals
plot1_electricity <- autoplot(resid_electricity_ts, series="Detrended Electricity", colour = "#00BFC4") + 
  theme_bw() +
  xlab("Time") +
  ylab("Residuals") +
  ggtitle("Detrended Electricity")

# Differencing plot
plot2_electricity <- autoplot(diff(total_electricity_ts), series = "First Difference Electricity", colour = "#F8766D") + 
  theme_bw() +
  xlab("Time") +
  ylab("Differences") +
  ggtitle("First Difference Electricity")

# Arrange plots
grid.arrange(plot1_electricity, plot2_electricity, nrow = 2)


```

**Detrended:**

The detrended plot of electricity prices displays clear periodic fluctuations, suggesting the presence of seasonality.

**First Difference:**

The first differenced series oscillates around a central mean, which is indicative of stationarity in the mean of the series. However, the consistent pattern of spikes followed by a return to the mean---indicates a strong seasonal component.

## GDP

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Detrending using the original data frame
fit_gdp <- lm(GDP ~ DATE, data = gdp_data, na.action = NULL)

# Convert residuals to a ts object for plotting
resid_gdp_ts <- ts(resid(fit_gdp), start=c(start_year_gdp, start_quarter_gdp), frequency=4)

# Plot the residuals
plot1_gdp <- autoplot(resid_gdp_ts, series="Detrended GDP", colour = "#00BFC4") + 
  theme_bw() +
  xlab("Time") +
  ylab("Residuals") +
  ggtitle("Detrended GDP")

# Differencing plot
plot2_gdp <- autoplot(diff(gdp_ts), series = "First Difference GDP", colour = "#F8766D") + 
  theme_bw() +
  xlab("Time") +
  ylab("Differences") +
  ggtitle("First Difference GDP")

# Arrange plots
grid.arrange(plot1_gdp, plot2_gdp, nrow = 2)


```

**Detrended:**

The detrended GDP plot showcases that the residuals seem to have a non-linear component, as evidenced by the gradual decline and subsequent increase over time. The residuals decrease and then slowly begin to rise after the 1980s, accelerating significantly in recent years. GDP growth rate is not constant and a simple linear model may not be sufficient to capture the complexities.

**First Difference:**

The differenced series predominantly hovers around the zero line, which indicates that this transformation effectively removes the trend from the data, leading to a stationary series in terms of the mean. The substantial spike observed towards the end is likely due to the recent economic downturn due to the COVID-19 pandemic, which represents a significant economic shock not accounted for by typical GDP growth patterns.

## CPI

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Detrending using the original data frame
fit_cpi <- lm(CPIAUCSL ~ DATE, data = cpi_data, na.action = NULL)

# Convert residuals to a ts object for plotting
resid_cpi_ts <- ts(resid(fit_cpi), start=c(start_year_cpi, start_month_cpi), frequency=12)

# Plot the residuals
plot1_cpi <- autoplot(resid_cpi_ts, series="Detrended CPI", colour = "#00BFC4") + 
  theme_bw() +
  xlab("Time") +
  ylab("Residuals") +
  ggtitle("Detrended CPI")

# Differencing plot
plot2_cpi <- autoplot(diff(cpi_ts), series = "First Difference CPI", colour = "#F8766D") + 
  theme_bw() +
  xlab("Time") +
  ylab("Differences") +
  ggtitle("First Difference CPI")

# Arrange plots
grid.arrange(plot1_cpi, plot2_cpi, nrow = 2)


```

**Detrended:**

The detrended CPI plot reveals residuals that decline over a prolonged period before stabilizing and then increasing. This pattern suggests that a simple linear trend does not fully capture the complexity of the inflationary trend over time.

**First Difference:**

The first difference plot for CPI demonstrates a series that fluctuates around a central mean value.

## 
:::

# Original Vs First Difference

Time series data often embody intrinsic trends and seasonality, which can confound analyses if not properly addressed. Two techniques to transform such data into a stationary are detrending and differencing.

Detrending involves the removal of a trend line from the time series, thus flattening the data into a horizontal line around the mean. 

Differencing, on the other hand, involves computing the difference between consecutive observations. This method is effective in eliminating both trend and seasonality, transforming the series into one where the mean level does not change over time. Differencing is a critical step in preparing data for ARIMA (AutoRegressive Integrated Moving Average) modeling.



::: panel-tabset



## Crude Oil

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Create the time series plot for the original CPI data
plot1 <- ggplot(cpi_data, aes(x = DATE, y = CPIAUCSL)) + 
  geom_line(colour = "turquoise4") + 
  theme_bw() +
  xlab("Time") + 
  ylab("CPI") +
  ggtitle("Original CPI Data")

# Create the time series plot for the first-differenced CPI data
# Calculate the first differences
cpi_data$Diff_CPIAUCSL <- c(NA, diff(cpi_data$CPIAUCSL))

# Plot the first differences
plot2 <- ggplot(cpi_data, aes(x = DATE, y = Diff_CPIAUCSL)) + 
  geom_line(colour = "#c65e57") + 
  theme_bw() +
  xlab("Time") + 
  ylab("First Differences") +
  ggtitle("First Differenced CPI Data")

# Arrange the two plots side by side
grid.arrange(plot1, plot2, nrow = 2)

```



## Natural Gas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Create the time series plot for the original Natural Gas data
plot1_ng <- ggplot(citygate_gas_prices, aes(x = Date, y = Value)) + 
  geom_line(colour = "turquoise4") + 
  theme_bw() +
  xlab("Time") + 
  ylab("Natural Gas Prices") +
  ggtitle("Original Natural Gas Data")

# Create the time series plot for the first-differenced Natural Gas data
# Calculate the first differences
citygate_gas_prices$Diff_Value <- c(NA, diff(citygate_gas_prices$Value))

# Plot the first differences
plot2_ng <- ggplot(citygate_gas_prices, aes(x = Date, y = Diff_Value)) + 
  geom_line(colour = "#c65e57") + 
  theme_bw() +
  xlab("Time") + 
  ylab("First Differences") +
  ggtitle("First Differenced Natural Gas Data")

# Arrange the two plots one above the other
grid.arrange(plot1_ng, plot2_ng, nrow = 2)
```



## Electricity

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Create the time series plot for the original Electricity data
plot1_elec <- ggplot(total_electricity_prices, aes(x = Date, y = Value)) + 
  geom_line(colour = "turquoise4") + 
  theme_bw() +
  xlab("Time") + 
  ylab("Electricity Prices") +
  ggtitle("Original Electricity Data")

# Create the time series plot for the first-differenced Electricity data
# Calculate the first differences
total_electricity_prices$Diff_Value <- c(NA, diff(total_electricity_prices$Value))

# Plot the first differences
plot2_elec <- ggplot(total_electricity_prices, aes(x = Date, y = Diff_Value)) + 
  geom_line(colour = "#c65e57") + 
  theme_bw() +
  xlab("Time") + 
  ylab("First Differences") +
  ggtitle("First Differenced Electricity Data")

# Arrange the two plots one above the other
grid.arrange(plot1_elec, plot2_elec, nrow = 2)


```


## GDP

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Create the time series plot for the original GDP data
plot1_gdp <- ggplot(gdp_data, aes(x = DATE, y = GDP)) + 
  geom_line(colour = "turquoise4") + 
  theme_bw() +
  xlab("Time") + 
  ylab("GDP (in billions)") +
  ggtitle("Original GDP Data")

# Create the time series plot for the first-differenced GDP data
# Calculate the first differences
gdp_data$Diff_GDP <- c(NA, diff(gdp_data$GDP))

# Plot the first differences
plot2_gdp <- ggplot(gdp_data, aes(x = DATE, y = Diff_GDP)) + 
  geom_line(colour = "#c65e57") + 
  theme_bw() +
  xlab("Time") + 
  ylab("First Differences") +
  ggtitle("First Differenced GDP Data")

# Arrange the two plots one above the other
grid.arrange(plot1_gdp, plot2_gdp, nrow = 2)


```


## CPI

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Plot the original CPI data
plot1_cpi <- ggplot(cpi_data, aes(x = DATE, y = CPIAUCSL)) + 
  geom_line(colour = "turquoise4") + 
  theme_bw() +
  xlab("Time") + 
  ylab("CPI") +
  ggtitle("Original CPI Data")

# Create the time series plot for the first-differenced CPI data
# Calculate the first differences
cpi_data$Diff_CPIAUCSL <- c(NA, diff(cpi_data$CPIAUCSL))

# Plot the first differences
plot2_cpi <- ggplot(cpi_data, aes(x = DATE, y = Diff_CPIAUCSL)) + 
  geom_line(colour = "#c65e57") + 
  theme_bw() +
  xlab("Time") + 
  ylab("First Differences") +
  ggtitle("First Differenced CPI Data")

# Arrange the two plots vertically
grid.arrange(plot1_cpi, plot2_cpi, nrow = 2)

```


## 

:::

# Dickey-Fuller Test

The Dickey-Fuller test is a statistical test used to determine the presence of unit root in a time series and, consequently, whether the series is non-stationary. The null hypothesis of the test is that the time series is non-stationary. If the p-value is less than the chosen alpha level (usually 0.05), we reject the null hypothesis and infer that the series is stationary.

::: panel-tabset

## Crude Oil

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Dickey-Fuller Test for Crude Oil
adf_test_crude_oil <- tseries::adf.test(composite_crude_oil_ts)

# Display the test results
adf_test_crude_oil


```

Since the p-value is greater than 0.05, we do not reject the null hypothesis and conclude that the crude oil price series is non-stationary, indicating that differencing or transformation may be required to achieve stationarity.

## Natural Gas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Dickey-Fuller Test for Natural Gas
adf_test_natural_gas <- tseries::adf.test(citygate_gas_ts)

# Display the test results
adf_test_natural_gas


```

The p-value suggests that the natural gas price series is non-stationary, reinforcing the need for potential differencing or other transformations to stabilize the series.

## Electricity

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Dickey-Fuller Test for Electricity
adf_test_electricity <- tseries::adf.test(total_electricity_ts)

# Display the test results
adf_test_electricity


```

With the p-value well above 0.05, the electricity price series is considered non-stationary, indicating that adjustments are necessary to model the series accurately.

## GDP

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Dickey-Fuller Test for GDP
adf_test_gdp <- tseries::adf.test(gdp_ts)

# Display the test results
adf_test_gdp

```

The extremely high p-value indicates that the GDP series is strongly non-stationary, suggesting that it would benefit from differencing or other methods to achieve stationarity.

## CPI

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Dickey-Fuller Test for CPI
adf_test_cpi <- tseries::adf.test(cpi_ts)

# Display the test results
adf_test_cpi


```

The CPI series is also non-stationary based on the high p-value, indicating that preprocessing steps are needed before further analysis or modeling.

## 

:::

These Dickey-Fuller test results across different datasets corroborate our earlier analyses and ACF & PACF plot interpretations, showing a common theme of non-stationarity in the series.

# First vs Second Differencing

In time series analysis, differencing is a technique used to stabilize the mean of a series and make it stationary. When trends and seasonality are present in a time series, they can affect the predictive models. Differencing helps to mitigate these influences by focusing on the changes in the data rather than the actual values.

Differencing operates under the principle of transformation. It is designed to remove specific types of patterns:

-   First Differencing: This method subtracts the current observation from the previous one. It is a powerful tool to eliminate trends and some types of seasonality in the data, providing a clearer view of the underlying cyclical components and irregularities.

-   Second Differencing: When first differencing is not enough to achieve stationarity, or when the time series exhibits a more complex pattern such as a trend within a trend, second differencing can be employed. This involves applying the differencing operation twice, which can further simplify the predictive structure by reducing more complex serial correlations.

::: panel-tabset
## Crude Oil

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# First Differencing
first_diff_crude_oil <- diff(composite_crude_oil_ts)
ggtsdisplay(first_diff_crude_oil, main = "First Differencing of Crude Oil Prices")

# Second Differencing
second_diff_crude_oil <- diff(first_diff_crude_oil)
ggtsdisplay(second_diff_crude_oil, main = "Second Differencing of Crude Oil Prices")
```

## Natural Gas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# First Differencing
first_diff_natural_gas <- diff(citygate_gas_ts)
ggtsdisplay(first_diff_natural_gas, main = "First Differencing of Natural Gas Prices")

# Second Differencing
second_diff_natural_gas <- diff(first_diff_natural_gas)
ggtsdisplay(second_diff_natural_gas, main = "Second Differencing of Natural Gas Prices")

```

## Electricity

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# First Differencing
first_diff_electricity <- diff(total_electricity_ts)
ggtsdisplay(first_diff_electricity, main = "First Differencing of Electricity Prices")

# Second Differencing
second_diff_electricity <- diff(first_diff_electricity)
ggtsdisplay(second_diff_electricity, main = "Second Differencing of Electricity Prices")

```

## GDP

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# First Differencing
first_diff_gdp <- diff(gdp_ts)
ggtsdisplay(first_diff_gdp, main = "First Differencing of GDP")

# Second Differencing
second_diff_gdp <- diff(first_diff_gdp)
ggtsdisplay(second_diff_gdp, main = "Second Differencing of GDP")

```

## CPI

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true


# First Differencing
first_diff_cpi <- diff(cpi_ts)
ggtsdisplay(first_diff_cpi, main = "First Differencing of CPI")

# Second Differencing
second_diff_cpi <- diff(first_diff_cpi)
ggtsdisplay(second_diff_cpi, main = "Second Differencing of CPI")

```

## 
:::

# AIC & BIC

In time series analysis, choosing the right model is paramount for accurate forecasting. Two of the most critical metrics for model selection are the Akaike Information Criterion (AIC) and the Bayesian Information Criterion (BIC). Both criteria are grounded in information theory and provide a means to balance model fit with model complexity.

-   AIC is a tool for model selection that quantifies the trade-offs between model complexity (the number of parameters in the model) and the goodness of fit. AIC rewards models that achieve a high goodness of fit but penalizes those that become overly complex. A lower AIC value often indicates a preferable model.

-   BIC extends the logic of AIC by incorporating sample size into the penalty for complexity. This adjustment makes BIC more stringent with complex models when dealing with larger datasets. As with AIC, a lower BIC suggests a better model.

::: panel-tabset
## Crude Oil

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true


d=1
i=1
temp= data.frame()
ls=matrix(rep(NA,6*25),nrow=25)


for (p in 1:5)
{
  for(q in 1:5)
  {
      if(p-1+d+q-1<=8) 
      {
        
        model<- Arima(composite_crude_oil_ts,order=c(p-1,d,q-1),include.drift=TRUE) 
        ls[i,]= c(p-1,d,q-1,model$aic,model$bic,model$aicc)
        i=i+1
      }
      
    }
  }

temp= as.data.frame(ls)
names(temp)= c("p","d","q","AIC","BIC","AICc")

temp[which.min(temp$AIC),]



# Find and display the models with the minimum AIC, BIC, and AICc
temp[which.min(temp$AIC),]
temp[which.min(temp$BIC),]
temp[which.min(temp$AICc),]
```

## Natural Gas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

d=1
i=1
temp= data.frame()
ls=matrix(rep(NA,6*25),nrow=25)


for (p in 1:5)
{
  for(q in 1:5)
  {
      if(p-1+d+q-1<=8) 
      {
        
        model<- Arima(citygate_gas_ts,order=c(p-1,d,q-1),include.drift=TRUE) 
        ls[i,]= c(p-1,d,q-1,model$aic,model$bic,model$aicc)
        i=i+1
      }
      
    }
  }

temp= as.data.frame(ls)
names(temp)= c("p","d","q","AIC","BIC","AICc")

temp[which.min(temp$AIC),]



# Find and display the models with the minimum AIC, BIC, and AICc
temp[which.min(temp$AIC),]
temp[which.min(temp$BIC),]
temp[which.min(temp$AICc),]

```

## Electricity

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

d=1
i=1
temp= data.frame()
ls=matrix(rep(NA,6*25),nrow=25)


for (p in 1:5)
{
  for(q in 1:5)
  {
      if(p-1+d+q-1<=8) 
      {
        
        model<- Arima(resid_electricity_ts,order=c(p-1,d,q-1),include.drift=TRUE) 
        ls[i,]= c(p-1,d,q-1,model$aic,model$bic,model$aicc)
        i=i+1
      }
      
    }
  }

temp= as.data.frame(ls)
names(temp)= c("p","d","q","AIC","BIC","AICc")

temp[which.min(temp$AIC),]



# Find and display the models with the minimum AIC, BIC, and AICc
temp[which.min(temp$AIC),]
temp[which.min(temp$BIC),]
temp[which.min(temp$AICc),]

```

## GDP

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

d=1
i=1
temp= data.frame()
ls=matrix(rep(NA,6*4),nrow=4)


for (p in 1:2)
{
  for(q in 1:2)
  {
      if(p-1+d+q-1<=8) 
      {
        
        model<- Arima(gdp_ts,order=c(p-1,d,q-1),include.drift=TRUE) 
        ls[i,]= c(p-1,d,q-1,model$aic,model$bic,model$aicc)
        i=i+1
      }
      
    }
  }

temp= as.data.frame(ls)
names(temp)= c("p","d","q","AIC","BIC","AICc")

temp[which.min(temp$AIC),]



# Find and display the models with the minimum AIC, BIC, and AICc
temp[which.min(temp$AIC),]
temp[which.min(temp$BIC),]
temp[which.min(temp$AICc),]

```

## CPI

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true
#| 
d=1
i=1
temp= data.frame()
ls=matrix(rep(NA,6*5),nrow=5)


for (p in 1:2)
{
  for(q in 1:2)
  {
      if(p-1+d+q-1<=8) 
      {
        
        model<- Arima(gdp_ts,order=c(p-1,d,q-1),include.drift=TRUE) 
        ls[i,]= c(p-1,d,q-1,model$aic,model$bic,model$aicc)
        i=i+1
      }
      
    }
  }

temp= as.data.frame(ls)
names(temp)= c("p","d","q","AIC","BIC","AICc")

temp[which.min(temp$AIC),]



# Find and display the models with the minimum AIC, BIC, and AICc
temp[which.min(temp$AIC),]
temp[which.min(temp$BIC),]
temp[which.min(temp$AICc),]

```

## 
:::

# Fitting ARIMA

Moving average smoothing is a time series forecasting method that can help identify long-term trends by smoothing out short-term fluctuations. By averaging the data over specific time windows, these methods filter out the 'noise' and offer a cleaner view of the direction in which the series is moving.

::: panel-tabset
## Crude Oil

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Prepare the data frame with the correct start date
crude_oil_df <- data.frame(
  Date = seq(as.Date("1973-10-01"), by = "month", length.out = length(composite_crude_oil_ts)),
  Value = as.vector(composite_crude_oil_ts)
)

# Calculate moving averages with the specified window sizes
crude_oil_df$ma5 <- zoo::rollmean(crude_oil_df$Value, 5, mean, fill = NA, align = "right")
crude_oil_df$ma15 <- zoo::rollmean(crude_oil_df$Value, 15, mean, fill = NA, align = "right")
crude_oil_df$ma20 <- zoo::rollmean(crude_oil_df$Value, 20, mean, fill = NA, align = "right")
crude_oil_df$ma30 <- zoo::rollmean(crude_oil_df$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p <- ggplot(crude_oil_df, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Value (USD)") +
  ggtitle('Crude Oil Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p)



```

## Natural Gas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

natural_gas_df <- data.frame(
  Date = seq(as.Date("1973-10-01"), by = "month", length.out = length(citygate_gas_ts)),
  Value = as.vector(citygate_gas_ts)
)

# Calculate moving averages with the specified window sizes
natural_gas_df$ma5 <- zoo::rollmean(natural_gas_df$Value, 5, mean, fill = NA, align = "right")
natural_gas_df$ma15 <- zoo::rollmean(natural_gas_df$Value, 15, mean, fill = NA, align = "right")
natural_gas_df$ma20 <- zoo::rollmean(natural_gas_df$Value, 20, mean, fill = NA, align = "right")
natural_gas_df$ma30 <- zoo::rollmean(natural_gas_df$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p_ng <- ggplot(natural_gas_df, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Value (Price)") +
  ggtitle('Natural Gas Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_ng)

```

## Electricity

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Calculate moving averages with the specified window sizes
total_electricity_prices$ma5 <- zoo::rollmean(total_electricity_prices$Value, 5, mean, fill = NA, align = "right")
total_electricity_prices$ma15 <- zoo::rollmean(total_electricity_prices$Value, 15, mean, fill = NA, align = "right")
total_electricity_prices$ma20 <- zoo::rollmean(total_electricity_prices$Value, 20, mean, fill = NA, align = "right")
total_electricity_prices$ma30 <- zoo::rollmean(total_electricity_prices$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p_electricity <- ggplot(total_electricity_prices, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Price (Cents per Kilowatthour)") +
  ggtitle('Electricity Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_electricity)

```

## GDP

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Calculate moving averages with the specified window sizes
gdp_data$ma5 <- zoo::rollmean(gdp_data$GDP, 5, mean, fill = NA, align = "right", by = 4)  # Considering quarterly data
gdp_data$ma15 <- zoo::rollmean(gdp_data$GDP, 15, mean, fill = NA, align = "right", by = 4)
gdp_data$ma20 <- zoo::rollmean(gdp_data$GDP, 20, mean, fill = NA, align = "right", by = 4)
gdp_data$ma30 <- zoo::rollmean(gdp_data$GDP, 30, mean, fill = NA, align = "right", by = 4)

# Create the ggplot object with a color aesthetic for the legend
p_gdp <- ggplot(gdp_data, aes(x = DATE)) + 
  geom_line(aes(y = GDP, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("GDP (in billions)") +
  ggtitle('GDP with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_gdp)

```

## CPI

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true
#| 
# Calculate moving averages with the specified window sizes
# Replace 'fill = NA' with 'fill = ifelse(is.na(.), NA, mean(., na.rm = TRUE))' if you want to avoid NA in your moving averages
cpi_data$ma5 <- zoo::rollmean(cpi_data$CPIAUCSL, 5, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma15 <- zoo::rollmean(cpi_data$CPIAUCSL, 15, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma20 <- zoo::rollmean(cpi_data$CPIAUCSL, 20, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma30 <- zoo::rollmean(cpi_data$CPIAUCSL, 30, fill = NA, align = "right", by.column = FALSE)

# Create the ggplot object with a color aesthetic for the legend
p_cpi <- ggplot(cpi_data, aes(x = DATE)) + 
  geom_line(aes(y = CPIAUCSL, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("CPIAUCSL") +
  ggtitle('CPI with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_cpi)

```

## 
:::

# Model Diagnostics

Moving average smoothing is a time series forecasting method that can help identify long-term trends by smoothing out short-term fluctuations. By averaging the data over specific time windows, these methods filter out the 'noise' and offer a cleaner view of the direction in which the series is moving.

::: panel-tabset
## Crude Oil

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Prepare the data frame with the correct start date
crude_oil_df <- data.frame(
  Date = seq(as.Date("1973-10-01"), by = "month", length.out = length(composite_crude_oil_ts)),
  Value = as.vector(composite_crude_oil_ts)
)

# Calculate moving averages with the specified window sizes
crude_oil_df$ma5 <- zoo::rollmean(crude_oil_df$Value, 5, mean, fill = NA, align = "right")
crude_oil_df$ma15 <- zoo::rollmean(crude_oil_df$Value, 15, mean, fill = NA, align = "right")
crude_oil_df$ma20 <- zoo::rollmean(crude_oil_df$Value, 20, mean, fill = NA, align = "right")
crude_oil_df$ma30 <- zoo::rollmean(crude_oil_df$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p <- ggplot(crude_oil_df, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Value (USD)") +
  ggtitle('Crude Oil Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p)



```

## Natural Gas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

natural_gas_df <- data.frame(
  Date = seq(as.Date("1973-10-01"), by = "month", length.out = length(citygate_gas_ts)),
  Value = as.vector(citygate_gas_ts)
)

# Calculate moving averages with the specified window sizes
natural_gas_df$ma5 <- zoo::rollmean(natural_gas_df$Value, 5, mean, fill = NA, align = "right")
natural_gas_df$ma15 <- zoo::rollmean(natural_gas_df$Value, 15, mean, fill = NA, align = "right")
natural_gas_df$ma20 <- zoo::rollmean(natural_gas_df$Value, 20, mean, fill = NA, align = "right")
natural_gas_df$ma30 <- zoo::rollmean(natural_gas_df$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p_ng <- ggplot(natural_gas_df, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Value (Price)") +
  ggtitle('Natural Gas Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_ng)

```

## Electricity

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Calculate moving averages with the specified window sizes
total_electricity_prices$ma5 <- zoo::rollmean(total_electricity_prices$Value, 5, mean, fill = NA, align = "right")
total_electricity_prices$ma15 <- zoo::rollmean(total_electricity_prices$Value, 15, mean, fill = NA, align = "right")
total_electricity_prices$ma20 <- zoo::rollmean(total_electricity_prices$Value, 20, mean, fill = NA, align = "right")
total_electricity_prices$ma30 <- zoo::rollmean(total_electricity_prices$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p_electricity <- ggplot(total_electricity_prices, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Price (Cents per Kilowatthour)") +
  ggtitle('Electricity Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_electricity)

```

## GDP

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Calculate moving averages with the specified window sizes
gdp_data$ma5 <- zoo::rollmean(gdp_data$GDP, 5, mean, fill = NA, align = "right", by = 4)  # Considering quarterly data
gdp_data$ma15 <- zoo::rollmean(gdp_data$GDP, 15, mean, fill = NA, align = "right", by = 4)
gdp_data$ma20 <- zoo::rollmean(gdp_data$GDP, 20, mean, fill = NA, align = "right", by = 4)
gdp_data$ma30 <- zoo::rollmean(gdp_data$GDP, 30, mean, fill = NA, align = "right", by = 4)

# Create the ggplot object with a color aesthetic for the legend
p_gdp <- ggplot(gdp_data, aes(x = DATE)) + 
  geom_line(aes(y = GDP, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("GDP (in billions)") +
  ggtitle('GDP with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_gdp)

```

## CPI

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true
#| 
# Calculate moving averages with the specified window sizes
# Replace 'fill = NA' with 'fill = ifelse(is.na(.), NA, mean(., na.rm = TRUE))' if you want to avoid NA in your moving averages
cpi_data$ma5 <- zoo::rollmean(cpi_data$CPIAUCSL, 5, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma15 <- zoo::rollmean(cpi_data$CPIAUCSL, 15, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma20 <- zoo::rollmean(cpi_data$CPIAUCSL, 20, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma30 <- zoo::rollmean(cpi_data$CPIAUCSL, 30, fill = NA, align = "right", by.column = FALSE)

# Create the ggplot object with a color aesthetic for the legend
p_cpi <- ggplot(cpi_data, aes(x = DATE)) + 
  geom_line(aes(y = CPIAUCSL, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("CPIAUCSL") +
  ggtitle('CPI with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_cpi)

```

## 
:::

# Auto.Arima()

Moving average smoothing is a time series forecasting method that can help identify long-term trends by smoothing out short-term fluctuations. By averaging the data over specific time windows, these methods filter out the 'noise' and offer a cleaner view of the direction in which the series is moving.

::: panel-tabset
## Crude Oil

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Prepare the data frame with the correct start date
crude_oil_df <- data.frame(
  Date = seq(as.Date("1973-10-01"), by = "month", length.out = length(composite_crude_oil_ts)),
  Value = as.vector(composite_crude_oil_ts)
)

# Calculate moving averages with the specified window sizes
crude_oil_df$ma5 <- zoo::rollmean(crude_oil_df$Value, 5, mean, fill = NA, align = "right")
crude_oil_df$ma15 <- zoo::rollmean(crude_oil_df$Value, 15, mean, fill = NA, align = "right")
crude_oil_df$ma20 <- zoo::rollmean(crude_oil_df$Value, 20, mean, fill = NA, align = "right")
crude_oil_df$ma30 <- zoo::rollmean(crude_oil_df$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p <- ggplot(crude_oil_df, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Value (USD)") +
  ggtitle('Crude Oil Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p)



```

## Natural Gas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

natural_gas_df <- data.frame(
  Date = seq(as.Date("1973-10-01"), by = "month", length.out = length(citygate_gas_ts)),
  Value = as.vector(citygate_gas_ts)
)

# Calculate moving averages with the specified window sizes
natural_gas_df$ma5 <- zoo::rollmean(natural_gas_df$Value, 5, mean, fill = NA, align = "right")
natural_gas_df$ma15 <- zoo::rollmean(natural_gas_df$Value, 15, mean, fill = NA, align = "right")
natural_gas_df$ma20 <- zoo::rollmean(natural_gas_df$Value, 20, mean, fill = NA, align = "right")
natural_gas_df$ma30 <- zoo::rollmean(natural_gas_df$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p_ng <- ggplot(natural_gas_df, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Value (Price)") +
  ggtitle('Natural Gas Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_ng)

```

## Electricity

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Calculate moving averages with the specified window sizes
total_electricity_prices$ma5 <- zoo::rollmean(total_electricity_prices$Value, 5, mean, fill = NA, align = "right")
total_electricity_prices$ma15 <- zoo::rollmean(total_electricity_prices$Value, 15, mean, fill = NA, align = "right")
total_electricity_prices$ma20 <- zoo::rollmean(total_electricity_prices$Value, 20, mean, fill = NA, align = "right")
total_electricity_prices$ma30 <- zoo::rollmean(total_electricity_prices$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p_electricity <- ggplot(total_electricity_prices, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Price (Cents per Kilowatthour)") +
  ggtitle('Electricity Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_electricity)

```

## GDP

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Calculate moving averages with the specified window sizes
gdp_data$ma5 <- zoo::rollmean(gdp_data$GDP, 5, mean, fill = NA, align = "right", by = 4)  # Considering quarterly data
gdp_data$ma15 <- zoo::rollmean(gdp_data$GDP, 15, mean, fill = NA, align = "right", by = 4)
gdp_data$ma20 <- zoo::rollmean(gdp_data$GDP, 20, mean, fill = NA, align = "right", by = 4)
gdp_data$ma30 <- zoo::rollmean(gdp_data$GDP, 30, mean, fill = NA, align = "right", by = 4)

# Create the ggplot object with a color aesthetic for the legend
p_gdp <- ggplot(gdp_data, aes(x = DATE)) + 
  geom_line(aes(y = GDP, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("GDP (in billions)") +
  ggtitle('GDP with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_gdp)

```

## CPI

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true
#| 
# Calculate moving averages with the specified window sizes
# Replace 'fill = NA' with 'fill = ifelse(is.na(.), NA, mean(., na.rm = TRUE))' if you want to avoid NA in your moving averages
cpi_data$ma5 <- zoo::rollmean(cpi_data$CPIAUCSL, 5, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma15 <- zoo::rollmean(cpi_data$CPIAUCSL, 15, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma20 <- zoo::rollmean(cpi_data$CPIAUCSL, 20, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma30 <- zoo::rollmean(cpi_data$CPIAUCSL, 30, fill = NA, align = "right", by.column = FALSE)

# Create the ggplot object with a color aesthetic for the legend
p_cpi <- ggplot(cpi_data, aes(x = DATE)) + 
  geom_line(aes(y = CPIAUCSL, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("CPIAUCSL") +
  ggtitle('CPI with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_cpi)

```

## 
:::

# Forecasting

Moving average smoothing is a time series forecasting method that can help identify long-term trends by smoothing out short-term fluctuations. By averaging the data over specific time windows, these methods filter out the 'noise' and offer a cleaner view of the direction in which the series is moving.

::: panel-tabset
## Crude Oil

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Prepare the data frame with the correct start date
crude_oil_df <- data.frame(
  Date = seq(as.Date("1973-10-01"), by = "month", length.out = length(composite_crude_oil_ts)),
  Value = as.vector(composite_crude_oil_ts)
)

# Calculate moving averages with the specified window sizes
crude_oil_df$ma5 <- zoo::rollmean(crude_oil_df$Value, 5, mean, fill = NA, align = "right")
crude_oil_df$ma15 <- zoo::rollmean(crude_oil_df$Value, 15, mean, fill = NA, align = "right")
crude_oil_df$ma20 <- zoo::rollmean(crude_oil_df$Value, 20, mean, fill = NA, align = "right")
crude_oil_df$ma30 <- zoo::rollmean(crude_oil_df$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p <- ggplot(crude_oil_df, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Value (USD)") +
  ggtitle('Crude Oil Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p)



```

## Natural Gas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

natural_gas_df <- data.frame(
  Date = seq(as.Date("1973-10-01"), by = "month", length.out = length(citygate_gas_ts)),
  Value = as.vector(citygate_gas_ts)
)

# Calculate moving averages with the specified window sizes
natural_gas_df$ma5 <- zoo::rollmean(natural_gas_df$Value, 5, mean, fill = NA, align = "right")
natural_gas_df$ma15 <- zoo::rollmean(natural_gas_df$Value, 15, mean, fill = NA, align = "right")
natural_gas_df$ma20 <- zoo::rollmean(natural_gas_df$Value, 20, mean, fill = NA, align = "right")
natural_gas_df$ma30 <- zoo::rollmean(natural_gas_df$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p_ng <- ggplot(natural_gas_df, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Value (Price)") +
  ggtitle('Natural Gas Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_ng)

```

## Electricity

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Calculate moving averages with the specified window sizes
total_electricity_prices$ma5 <- zoo::rollmean(total_electricity_prices$Value, 5, mean, fill = NA, align = "right")
total_electricity_prices$ma15 <- zoo::rollmean(total_electricity_prices$Value, 15, mean, fill = NA, align = "right")
total_electricity_prices$ma20 <- zoo::rollmean(total_electricity_prices$Value, 20, mean, fill = NA, align = "right")
total_electricity_prices$ma30 <- zoo::rollmean(total_electricity_prices$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p_electricity <- ggplot(total_electricity_prices, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Price (Cents per Kilowatthour)") +
  ggtitle('Electricity Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_electricity)

```

## GDP

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Calculate moving averages with the specified window sizes
gdp_data$ma5 <- zoo::rollmean(gdp_data$GDP, 5, mean, fill = NA, align = "right", by = 4)  # Considering quarterly data
gdp_data$ma15 <- zoo::rollmean(gdp_data$GDP, 15, mean, fill = NA, align = "right", by = 4)
gdp_data$ma20 <- zoo::rollmean(gdp_data$GDP, 20, mean, fill = NA, align = "right", by = 4)
gdp_data$ma30 <- zoo::rollmean(gdp_data$GDP, 30, mean, fill = NA, align = "right", by = 4)

# Create the ggplot object with a color aesthetic for the legend
p_gdp <- ggplot(gdp_data, aes(x = DATE)) + 
  geom_line(aes(y = GDP, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("GDP (in billions)") +
  ggtitle('GDP with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_gdp)

```

## CPI

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true
#| 
# Calculate moving averages with the specified window sizes
# Replace 'fill = NA' with 'fill = ifelse(is.na(.), NA, mean(., na.rm = TRUE))' if you want to avoid NA in your moving averages
cpi_data$ma5 <- zoo::rollmean(cpi_data$CPIAUCSL, 5, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma15 <- zoo::rollmean(cpi_data$CPIAUCSL, 15, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma20 <- zoo::rollmean(cpi_data$CPIAUCSL, 20, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma30 <- zoo::rollmean(cpi_data$CPIAUCSL, 30, fill = NA, align = "right", by.column = FALSE)

# Create the ggplot object with a color aesthetic for the legend
p_cpi <- ggplot(cpi_data, aes(x = DATE)) + 
  geom_line(aes(y = CPIAUCSL, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("CPIAUCSL") +
  ggtitle('CPI with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_cpi)

```

## 
:::

# Comparing with Benchmark Methods

Moving average smoothing is a time series forecasting method that can help identify long-term trends by smoothing out short-term fluctuations. By averaging the data over specific time windows, these methods filter out the 'noise' and offer a cleaner view of the direction in which the series is moving.

::: panel-tabset
## Crude Oil

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Prepare the data frame with the correct start date
crude_oil_df <- data.frame(
  Date = seq(as.Date("1973-10-01"), by = "month", length.out = length(composite_crude_oil_ts)),
  Value = as.vector(composite_crude_oil_ts)
)

# Calculate moving averages with the specified window sizes
crude_oil_df$ma5 <- zoo::rollmean(crude_oil_df$Value, 5, mean, fill = NA, align = "right")
crude_oil_df$ma15 <- zoo::rollmean(crude_oil_df$Value, 15, mean, fill = NA, align = "right")
crude_oil_df$ma20 <- zoo::rollmean(crude_oil_df$Value, 20, mean, fill = NA, align = "right")
crude_oil_df$ma30 <- zoo::rollmean(crude_oil_df$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p <- ggplot(crude_oil_df, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Value (USD)") +
  ggtitle('Crude Oil Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p)



```

## Natural Gas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

natural_gas_df <- data.frame(
  Date = seq(as.Date("1973-10-01"), by = "month", length.out = length(citygate_gas_ts)),
  Value = as.vector(citygate_gas_ts)
)

# Calculate moving averages with the specified window sizes
natural_gas_df$ma5 <- zoo::rollmean(natural_gas_df$Value, 5, mean, fill = NA, align = "right")
natural_gas_df$ma15 <- zoo::rollmean(natural_gas_df$Value, 15, mean, fill = NA, align = "right")
natural_gas_df$ma20 <- zoo::rollmean(natural_gas_df$Value, 20, mean, fill = NA, align = "right")
natural_gas_df$ma30 <- zoo::rollmean(natural_gas_df$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p_ng <- ggplot(natural_gas_df, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Value (Price)") +
  ggtitle('Natural Gas Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_ng)

```

## Electricity

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Calculate moving averages with the specified window sizes
total_electricity_prices$ma5 <- zoo::rollmean(total_electricity_prices$Value, 5, mean, fill = NA, align = "right")
total_electricity_prices$ma15 <- zoo::rollmean(total_electricity_prices$Value, 15, mean, fill = NA, align = "right")
total_electricity_prices$ma20 <- zoo::rollmean(total_electricity_prices$Value, 20, mean, fill = NA, align = "right")
total_electricity_prices$ma30 <- zoo::rollmean(total_electricity_prices$Value, 30, mean, fill = NA, align = "right")

# Create the ggplot object with a color aesthetic for the legend
p_electricity <- ggplot(total_electricity_prices, aes(x = Date)) + 
  geom_line(aes(y = Value, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("Price (Cents per Kilowatthour)") +
  ggtitle('Electricity Price with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_electricity)

```

## GDP

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true

# Calculate moving averages with the specified window sizes
gdp_data$ma5 <- zoo::rollmean(gdp_data$GDP, 5, mean, fill = NA, align = "right", by = 4)  # Considering quarterly data
gdp_data$ma15 <- zoo::rollmean(gdp_data$GDP, 15, mean, fill = NA, align = "right", by = 4)
gdp_data$ma20 <- zoo::rollmean(gdp_data$GDP, 20, mean, fill = NA, align = "right", by = 4)
gdp_data$ma30 <- zoo::rollmean(gdp_data$GDP, 30, mean, fill = NA, align = "right", by = 4)

# Create the ggplot object with a color aesthetic for the legend
p_gdp <- ggplot(gdp_data, aes(x = DATE)) + 
  geom_line(aes(y = GDP, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("GDP (in billions)") +
  ggtitle('GDP with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_gdp)

```

## CPI

```{r, warning=FALSE, message=FALSE, echo=FALSE}
#| code-fold: true
#| code-summary: 'Importing Libraries'
#| warning: false
#| output: true
#| 
# Calculate moving averages with the specified window sizes
# Replace 'fill = NA' with 'fill = ifelse(is.na(.), NA, mean(., na.rm = TRUE))' if you want to avoid NA in your moving averages
cpi_data$ma5 <- zoo::rollmean(cpi_data$CPIAUCSL, 5, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma15 <- zoo::rollmean(cpi_data$CPIAUCSL, 15, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma20 <- zoo::rollmean(cpi_data$CPIAUCSL, 20, fill = NA, align = "right", by.column = FALSE)
cpi_data$ma30 <- zoo::rollmean(cpi_data$CPIAUCSL, 30, fill = NA, align = "right", by.column = FALSE)

# Create the ggplot object with a color aesthetic for the legend
p_cpi <- ggplot(cpi_data, aes(x = DATE)) + 
  geom_line(aes(y = CPIAUCSL, color = "Actual Data")) +
  geom_line(aes(y = ma5, color = "5-MA")) +
  geom_line(aes(y = ma15, color = "15-MA")) +
  geom_line(aes(y = ma20, color = "20-MA")) +
  geom_line(aes(y = ma30, color = "30-MA")) +
  xlab("Time") + ylab("CPIAUCSL") +
  ggtitle('CPI with Moving Averages') +
  theme_bw()

# Convert the ggplot object to a plotly object
plotly::ggplotly(p_cpi)

```

## 
:::
